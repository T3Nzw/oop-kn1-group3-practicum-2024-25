# Шаблони (Templates). Функции от по-висок ред (Higher Order Functions) - 27.02.2025
## Задача 01

Да се напише шаблон на функция, която разменя стойностите на две променливи от произволен тип.

*Забележка*: И двете променливи трябва да са от един и същи тип.

Пример:

```c++
int a = 10, b = 12;
swap(a,b);  //~> a==12, b==10

struct Point{ double x,y; } p1{4.5,3}, p2{12,7};
swap(p1,p2);  //~> p1=={12,7}, p2=={4.5,3} (магия?)
```

## Задача 02

Да се напише шаблон на функция, която приема два параметъра от произволен тип и връща по-големия от двата елемента. Ако типът на параметрите е число с плаваща запетая, да се използва сравнение с достатъчно малка константа епсилон, в противен случай - не.

## Задача 03

Да се напише шаблон на функция, която сортира елементите на масив по метода на мехурчето. Елементите на масива могат да са от произволен (един за всички) тип.

Пример:

```c++
int arri[]{3,7,1,9};
bubbleSort(arri,sizeof(arri)/sizeof(int));  
//~> [1,3,7,9]

char arrc[] = "a string is also an array!";
bubbleSort(arrc,sizeof(arrc)-1);
//~> "     !aaaaagiilnnorrrsssty"
```

## Задача 04

Да се напише шаблон на структура `Pair`, която представлява наредена двойка, чиито елементи могат да бъдат от различен тип. Освен това:

- да се напише функция, която форматира наредената двойка на конзолата;

- да се напише функция, която приема две наредени двойки и връща наредена двойка, получена от поелементното събиране на двата параметъра;

- да се напише функция, която приема наредена двойка `pair` и връща наредена двойка, съдържаща елементите на `pair`, но в обратен ред;

- да се напише функция, която сравнява двете наредени двойки лексикографски;

- да се напише функция, която сортира масив от наредени двойки, използвайки предната функция;

*Забележка 1*: Лексикографско сортиране на наредени двойки дефинираме по следния начин:

$$
(a,b) = (c,d) \iff a = c \land b = d 
$$

$$
(a,b) < (c,d) \iff a < c \lor (a = c \land b < d)
$$

$$
(a,b) > (c,d) \iff a > c \lor (a = c \land b > d)
$$

*Забележка 2*: Може да приемете, че за типовете на елементите, които участват в наредените двойки, съществуват необходимите функции / оператори.

## Задача 05

Да се напише функция, която по подадени начало и край на затворен интервал от цели числа и едноместна функция `f` намира броя неподвижни точки на `f` в дадения интервал.

*Забележка*: Неподвижна точка `x` на функция `f` е такава точка, за която `f(x)=x`.

## Задача 06

Да се напише шаблон на функция, която приема едноместна функция `f`, аргумент `x` и естествено число `n` и връща резултата от n-кратното прилагане на `f` върху `x`.

Пример:

```c++
int addOne(int x) { return x+1; }
apply(&addOne,4,0);  //~> 4
apply(&addOne,4,3);  //~> 7
```

## Задача 07

Да се напише шаблон на функция `BinaryOperation operation(char op)`, която по подадена операция `+`, `-`, `*`, `/` връща двуместна функция, изпълняваща съответната операция. Да се напише функция, която приема двуместна операция и два аргумента и връща резултата от прилагането на операцията върху двата операнда.

Пример:

```c++
apply(operation('+'),5,6);  //~> 11
apply(operation('*'),20.3,-1);  //~> -20.3 
```

## Задача 08

Нека е дадена следната структура:

```c++
template<typename T>
struct ResizingArray {
  T* data;
  size_t size;
  size_t capacity;
};
```

- да се напише шаблон на функция `ResizingArray<U> map(U(*f)(T const&), ResizingArray<T> const& arr)`, която по подадени едноместна функция `f` и преоразмеряващ се масив `arr` връща нов преоразмеряващ се масив, получен след поелементното прилагане на функцията `f` над масива, който съдържа `arr`.

- да се напише шаблон на функция `ResizingArray<T> filter(bool(*p)(T const&), ResizingArray<T> const& arr)`, която по подадени едноместен предикат `p` и преоразмеряващ се масив `arr` връща преоразмеряващ се масив, съставен от елементите на `arr`, които удовлетворяват предиката `p`.

*Забележка*: Погрижете се за правилното освобождаване на динамично заделената памет.

## Задача 09

Да се напише шаблон на функция `U accumulate(T* begin, T* end, U const& nv, U(*op)(U,T))`, която последователно прилага двуместната операция `op` над елементите в интервала, определен от указателите `begin` и `end`, започвайки от нулевата стойност `nv`.

Пример:

```c++
int arr[5]{1,2,3,4,5};
accumulate(arr,arr+4,0,[](int x, int y) -> int { return x+y; })
//~> 15
accumulate(arr,arr+4,'a',[](char x, int y) -> char { return (x+y)%256; })
//~> 'p'
```

## Задача 10

Да се напише функция, която приема двуместна операция `op` и ляв аргумент `arg`, която фиксира левия аргумент `arg` и връща функция на един аргумент.

Пример:

```c++
int add(int x, int y) { return x+y; }
partialFunctionApplication(add,3)(2);  //~> 5
```

*Обяснение на примера*: `partialFunctionApplication` приема като първи параметър двуместната функция `add` и целочисления параметър `3` и връща функция от вида `add(3,y)`, където `y` е някаква променлива. След това резултатната функция се прилага над параметър със стойност `2` и връща резултат `3+2=5`. 