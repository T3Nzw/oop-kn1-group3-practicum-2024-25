# Класове (Classes) - 06.03.2025

## Задача 01

Нека е дадена следната структура:

```c++
struct Point { double x, y; }
```

Да се напише клас `LineSegment`, който има следните методи (приемаме, че отсечката е насочена, т.е. има начало и край):

- `void setStartingPoint(Point const&)`, който променя координатите на началото на отсечката;

- `void setEndpoint(Point const&)`, който променя координатите на края на отсечката;

- `Point const& getStartingPoint() const`, който връща началната точка;

- `Point const& getEndpoint() const`, който връща крайната точка;

- `double length() const`, който връща дължината на отсечката;

- `double slope() const`, който връща наклона на правата, върху която лежи отсечката;

- `Point midpoint() const`, който връща координатите на средата на отсечката;

- `Point toVector() const`, който връща векторното представяне на отсечката;

- `bool containsPoint(Point const&) const`, който връща дали дадена точка лежи върху отсечката;

- `void translate(double dx, double dy)`, който транслира отсечката с хоризонтално отместване `dx` и вертикално отместване `dy`;

## Задача 02

Да се напише клас `BookTracker`, който позволява следните функционалности:

- добавяне на книга към списък от книги за бъдещо четене;

- отчитане на книга като прочетена;

- добавяне на книга към списък от книги, които читателят чете в момента;

- извеждане на всички книги според тяхната им категория (напр. прочетени книги);

- извеждане на всички книги от **конкретна** категория;

- даване оценка на книга.

## Задача 03

Да се разшири [Задача 02](#задача-02) по следните начини:

- да се създаде платформа, в която даден потребител може да следи какви книги е прочел, какво чете в момента и т.н., като:

  - прогресът на всеки потребител е индивидуален;

  - се изисква устойчивост, т.е. промените след края на потребителската сесия (напр. добавени книги за четене) се отразяват при следващото влизане в платформата от този потребител;

  - при всяко влизане в платформата се позволяват две възможности - създаване на нова регистрация и влизане във вече съществуващ потребителски профил. За улеснение може да приемете, че платформата има горна граница за максимален брой поддържани потребители;

  - всеки потребител има потребителско име и парола;

  - при запазване на паролата в системата тя **не** може да е в "суров" вид, т.е. трябва да се *хешира* (няма изискване за добра хешираща функция, може да е и нещо съвсем "неработещо" в реалния свят :D, напр. броят символи в паролата);

  - ако даден потребител не съществува, да се съобщи за грешка;

  - ако потребителят не е влязъл в профила си, той не може да извършва никакви операции в платформата;

  - след прекратяване на *програмата* всички промени се записват и при следващото ѝ изпълнение са налични в платформата.

- за горепосочената платформа да се създаде класация, която се извършва на база някаква функция за сравнение, като:

  - потребителите се сортират в класацията спрямо тази функция;

  - се създаде команда, която позволява визуализацията на текущата класация, независимо дали потребител в влязъл в профила си, или не;

  - функцията за сравнение е една от няколко предварително зададени такива;

  - потребителят може да избере критерий за сравнение чрез подаване на допълнителен аргумент на командата, например:

    ```
    >leaderboard most-read
    ```

    което би класирало потребителите в намаляващ ред на броя на прочетените им книги.