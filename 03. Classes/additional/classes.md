# Класове (Classes)

В основата на обектно-ориентираното програмиране (ООП) стоят класовете. Класовете, също както и структурите, се състоят от *полета/член-данни*, които могат да бъдат от различни типове.

Класовете са почти идентични на структурите, с една разлика - т.нар. *контрол на достъпа* по подразбиране. За него ще обясним малко по-надолу.

---

Можем да декларираме (forward declare) класове:

```c++
class ExampleClass;
```

да дефинираме класове по следния начин:

```c++
class ExampleClass {
  int x;
  double y;
  char z[10];
};  //важно е тук да има точка и запетая!
```

и да създаваме *обекти/инстанции на клас* по следния начин:

```c++
ExampleClass example;
```

Ако обаче се опитаме да достъпим някое от полетата на `example`, ще срещнем проблем:

```c++
example.x = 10;
// error: 'int ExampleClass::x' is private within this context
```

Това е, защото по подразбиране полетата на класовете са **private**.

## Контрол на достъпа

Именно чрез него е възможна т.нар. *капсулация* в ООП. Изразява се в това, че разполагаме с три (в C++) вида *спецификатори за достъп* (access specifiers):

- `public` - полетата са "публични", т.е. са достъпни извън самия клас;

- `private` - полетата са достъпни само в самия клас;

- `protected` - ще говорим за него, когато вземем наследяване.

### *Единствената* разлика между класове и структури е, че контролът на достъп при структурите по подразбиране е `public`, a при класовете - `private`.

Синтактично това са етикети, полетата под които са със съотвения достъп (до срещането на друг спефицикатор за достъп):

```c++
class ExampleClass {
public:
  int x;
private:
  double y;
  char z;
public:
  short a[10];
};

int main() {
  ExampleClass example;
  example.x = 10;  //ок
  example.a[5] = 4;  //ок
  example.y = 1.618;  //грешка - y е private
  example.z = 'o';  //грешка - z e private
}
```

Дотук обаче обяснихме само какво означава дадена член-данна да е достъпна извън класа. Какво обаче означава член-данна да е достъпна **само в класа**?

## Методи (член-функции)

Можем да създаваме функции, които можем да извикваме върху даден обект на класа. Тези функции, подобно на член-данните, се наричат член-функции (методи).

```c++
class Person {
public:
  //член-функциите също се влияят от спефицикаторите за достъп
  //селектори (getters)
  char const* getName() const { return name; }
  unsigned int getAge() const { return age; }
  //мутатори (setters)
  void setName(char const* _name) {
    strcpy(name,_name);
  }
  void setAge(unsigned int _age) { age = _age; }
private:
  char name[33];
  unsigned int age;
};
```

Както вече видяхме, не можем да достъпваме полетата `name` и `age` извън самия клас `Person`, но **можем да ги достъпваме вътре в него** - иначе казано, можем да ги достъпваме в член-функциите на класа. Как точно, ще разберем малко по-надолу.

Член-функциите се дефинират както и познатите ни досега функции, като в тялото им можем да използваме член-данните на класа. Член-функциите, които връщат стойността на някакво поле на класа, се наричат селектори (getters/accessors), a член-функциите, които променят стойността на някакво поле на класа, се наричат мутатори (setters/mutators).

##### Можем да извикваме методите на даден клас по следния начин:

```c++
int main() {
  Person p1, p2;
  p1.setName("Pesho");
  p1.setAge(19);
  p2.setName("Gosho");
  p2.setAge(20);
  //p1 и p2 са два различни обекта, затова и член-функциите им
  //работят с различни стойности!
  std::cout << p1.getName() << ' ' << p1.getAge() << std::endl;
  std::cout << p2.getName() << ' ' << p2.getAge() << std::endl; 
}
```

## Константни методи

По-горе в примера видяхме следната дефиниция на метод:

```c++
char const* getName() const { return name; }
```

Това са т.нар. *константни член-функции* - това означава, че са методи, които **не променят** стойностите на полетата в класа. Тоест,

```c++
char const* getName() const { 
  name[0] = '\0';  //не е позволено, ако методът е const!
  return name;
}
```

Забележете, че ако имахме следния клас:

```c++
class A {
public:
  void set(int* _ptr) { ptr = _ptr; }
  int* get() const {
    *ptr = 7;  //това е напълно валидно!
    return ptr;
  }
private:
  int* ptr;
};

int main() {
  int x = 12;
  A a;
  a.set(&x);  //a.ptr == &x
  //забележете, че операторът . е с по-висок приоритет
  //от оператора *
  std::cout << *a.get();  //*a.get() == 7
}
```

тази дефиниция на `get()` не би била проблемна, защото не променяме стойността на някое от полетата на `A` (в случая то е единствено) - променяме стойността, към която **сочи** указателят, но не променяме стойността на самия указател!

# Указателят `this`

Както видяхме в един от [по-горните примери](#можем-да-извикваме-методите-на-даден-клас-по-следния-начин), когато извикаме някой метод с определен обект, то този метод знае с кой обект работи и какви са неговите член-данни. Но как прави това?

За целта всяка член-функция на даден клас има **неявен** параметър - указател, чието име е `this`. Това е указател, който сочи към дадения обект в паметта, т.е. достъпването на полетата му се извършва на база отстъпи от този указател.

```c++
char const*  getName() const { return this->name; }
unsigned int getAge()  const { return this->age;  }
```

За non-const методи указателят `this` е от тип `X*`, а за const методи е от тип `X const*`, където `X` е името на някакъв клас / структура.

В повечето случаи можем да изпускаме изписването на `this` параметъра. Един от случаите, в които не бихме могли, е следният:

```c++
class A {
public:
  void setValue(int value) {
    this->value = value;  //правилно
    value = value;  //бихме присвоили стойността на value
                    //на параметъра value   
  }
private:
  int value;
};
```

## Разделна компилация (Separate compilation)

Освен познатите ни досега `.cpp` файлове (`.c` за *C*) съществуват и т.нар. *заглавни* файлове (*header files*), завършващи с разширението `.hpp` (`.h` за *C*). В тях са възможни декларации / дефиниции на променливи, функции, структури / класове и т.н. "Добавят" се към `.cpp` (source) файловете чрез *предпроцесорната директива* `#include <заглавен_файл>`. Това, което прави тя, е, че *дословно* копира и поставя съдържанието на целия заглавен файл.

Разделната компилация е процес, при който разделяме дадена програма на множество от файлове, всеки от който може да се компилира самостоятелно. Например, ако имаме даден клас `A`, бихме разделили самия интерфейс на класа (т.е. какви полета и методи има - декларациите) от самата имплементация (т.е. самата реализация на методите, техните дефиниции) по следния начин:

```c++
A.hpp
------------------
#ifndef __A_HPP
#define __A_HPP

class A {
public:
  void setValue(int);
  int getValue() const;
  void print() const;
private:
  int value;
};

#endif // __A_HPP
```

```c++
A.cpp
------------------
#include <iostream>
#include "A.hpp"

void A::setValue(int value) {
  this->value = value;
}

int A::getValue() const {
  return value;
}

void A::print() const {
  std::cout << value;
}
```

Забележете, че трябва да добавим `<iostream>` в `A.cpp`, тъй като иначе бихме получили компилационна грешка.

`#ifndef <макрос>`, `#define <макрос>` и `#endif` са т.нар. предпроцесорни директиви за дефиниция на макроси. `#ifndef <макрос>` (*if not defined*) проверява дали даден заглавен файл със същото име `<макрос>` вече не е добавен в даден файл, за да не се получат много едни и същи дефиниции (което е компилационна грешка).