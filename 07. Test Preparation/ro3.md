# Шаблон за реализация на голямата четворка

Нека `A` е някакъв клас, за който искаме да реализираме голямата четворка.

## Конструктор по подразбиране (Default constructor)

Инициализира полетата на класа със стойностите по подразбиране на съответните типове. Не връща резултат.

```c++
A::A() /*инициализация на полета със стойности по подразбиране*/ {
  //тяло на конструктора. присвояване на стойности,
  //по-сложна манипулация на полетата на класа
}
```

## Копиращ конструктор (Copy constructor)

Създава друг обект от класа `A`, използвайки друг, вече съществуващ обект от класа `A`. Не връща резултат.

```c++
A::A(A const& other) /*инициализация на полета със стойностите от other*/ {
  //тяло на конструктора. присвояване на стойности от other,
  //по-сложна манипулация на полетата на класа
}
```

## Копиращ оператор за присвояване (Copy assignment operator)

Присвоява друга стойност от класа `A` на **вече съществуващ** обект от класа `A`. Връща референция към текущия обект с цел позволяване на верижното извикване на `operator=`.

```c++
A& A::operator=(A const& other) {
  if (this != &other) {
    free();  //освобождаване на ресурсите, които се пазят от *this, ако има такива
    copy();  //копиране на новите стойности от other в *this
  }
  return *this;
}
```

## Деструктор (Destructor)

Освобождаване на ресурсите, които се притежават от обект от класа `A`. Не връща резултат.

```c++
A::~A() {
  free();  //освобождаване на ресурсите, които се пазят от *this, ако има такива
}
```

## Примери

- класът трябва да заделя динамична памет (конструкторите), тъй като името `name` може да е с произволна дължина, като след това е отговорен за освобождаването ѝ (чрез деструктора):

```c++
class Student {
public:
  //конструктор по подразбиране
  Student() : name(new char[1]{""}), fn(), year(0) {}

  //параметризиран конструктор (не е част от Г4!)
  Student(char const* name, char const* fn, unsigned year)
  : name(new char[strlen(name)+1]), year(year) {
    strcpy(this->name,name);
    strcpy(this->fn,fn);
  }

  //копиращ конструктор. бихме могли и просто да извикаме copy(other)
  //в тялото му, понеже можем и да не използваме инициализиращия списък тук.
  //това НЕВИНАГИ е така
  Student(Student const& other)
  : name(new char[strlen(other.name)+1]), year(other.year) {
    strcpy(name,other.name);
    strcpy(fn,other.fn);
  }

  //копиращ оператор за присвояване
  Student& operator=(Student const& other) {
    if (this != &other) {
      free();
      copy(other);
    }
    return *this;
  }

  //деструктор
  ~Student() { free(); }

private:
  //правим т.нар. deep copy, т.е.
  //копираме стойността в name, 
  //към която сочи other.name
  void copy(Student const& other) {
    name = new char[strlen(other.name)+1];
    strcpy(name,other.name);
    strcpy(fn,other.fn);
    year = other.year;
  }

  void free() { delete[] name; }

private:
  char* name;
  char fn[10];
  unsigned year;
};
```

- класът съдържа поле, което е референция:

```c++
template<typename T>
class ReferenceWrapper {
public:
  //НЯМА как да имаме конструктор по подразбиране.
  //можем експлицитно да укажем, че той е изтрит
  //(заради референцията не може автоматично да се създадат
  //методи от Г4, така че не е необходимо,
  //но е една идея по-ясно какво се случва)
  ReferenceWrapper()=delete;

  //параметризиран конструктор. 
  //m_ref трябва ЗАДЪЛЖИТЕЛНО да се инициализира
  //в инициализиращия списък
  ReferenceWrapper(T& ref) : m_ref(ref) {}

  //копиращ конструктор.
  //m_ref трябва ЗАДЪЛЖИТЕЛНО да се инициализира
  //в инициализиращия списък
  ReferenceWrapper(ReferenceWrapper const& other)
  : m_ref(other.m_ref) {}

  //НЯМА как да имаме оператор=, тъй като
  //референциите се свързват с променлива само веднъж.
  //отново, не е нужно експлицитно да изтриваме метода,
  //няма как да се създаде автоматично
  ReferenceWrapper& operator=(ReferenceWrapper const&)=delete;

  //можем и да не го пишем, тъй като
  //по подразбиране деструкторът не прави нищо.
  //еквивалентно е да напишем
  //~ReferenceWrapper() {}
  ~ReferenceWrapper()=default;

private:
  T& m_ref;
};
```

- искаме да имаме СПОДЕЛЕНА динамична памет:

```c++
template<typename T>
class Shared {
  //конструктор по подразбиране.
  //пишем го единствено защото искаме
  //m_data да има стойност по подразбиране
  Shared() : m_data(nullptr) {}

  //параметризиран конструктор.
  //правим т.нар. shallow copy 
  //(копираме само указателя)
  Shared(T* dataPtr) : m_data(dataPtr) {}

  //няма нужда да изписваме останалите 3
  //метода от Г4, понеже те се създават
  //автоматично и правят точно това, което искаме,
  //а именно копират самия указател.
  //можем да ги напишем експлицитно:
  Shared(Shared const&)=default;

  Shared& operator=(Shared const&)=default;

  //не искаме обектите от класа да притежават паметта,
  //към която сочат,
  //понеже тя може да е споделена между няколко
  //обекта и освобождаването ѝ при единия обект
  //би довело до освобождаването ѝ и при другия.
  //по-нататък в курса ще видим как може обектите
  //сами да се грижат за споделена между тях памет
  ~Shared()=default;

private:
  T* m_data;
};
```