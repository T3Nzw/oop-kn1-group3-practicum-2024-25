# Предефиниране на оператори (Operator Overloading) - 13.03.2025

#### В следващите задачи са описани *основните* функционалности, които се очакват от класовете, които сте написали. Това означава, че в определени случаи би следвало да реализирате и допълнителни методи, които да гарантират коректната работа на класа ви.

*TW*: Следват множество от задачи от дисциплините, изучавани предния семестър - Алгебра 1, Дискретни Структури, УП... Proceed at your own risk. :D

## Задача 00

Да се предефинират следните оператори за класа [String](/04.%20Rule%20of%20Three/README.md/#задача-01) от миналия път:

- `String operator+(String const& other)`, който конкатенира текущия низ с `other` и връща новополучения низ;

- `String& operator+=(String const& other)`, който долепя `other` към текущия низ;

- `char& operator[](size_t index)`, който достъпва елемента в низа на индекс `index`;

- `char const& operator[](size_t index) const`, който прави същото като горния метод;

- операторите `==`, `<`, `>`, `<=`, `>=` за сравнение на два низа; например първият оператор би имал сигнатурата `bool operator==(String const& other)`;

Да се предефинира операторът за индексиране за класа [Vector](/04.%20Rule%20of%20Three/README.md/#задача-02) от миналия път.

## Задача 01

Да се напише клас `Complex`, който представя комплексно число, състоящо се от реална и имагинерна част. Да се реализират следните методи:

- констуктор, който приема два параметъра - реална и имагинерна част на комплексното число;

- **унарен** `operator-`, който връща ново комплексно число с обърнат знак;

- `operator+`, чиито операнди са две комплексни числа и който връща ново комплексно число;

- `operator+=`, който добавя друго комплексно число към текущото;

- `operator-`, `operator-=`, `operator*`, `operator*=`, които са дефинирани аналогично на предните два оператора;

- `operator<<`, който извежда форматирано комплексното число в даден изходен поток;

- `operator>>`, който позволява въвеждане на реална и имагинерна част на комплексно число от даден входен поток;

- `operator*`, който като ляв или десен аргумент приема реално число и връща резултата от умножението на комплексното число по дадения скалар;

- префиксен и постфиксен `operator++`, който увеличава реалната част на числото с единица;

- метод, който връща комплексно спрегнатото на комплексното число;

- метод, който намира модула на комплексното число.

## Задача 02

Да се напише клас `unique_ptr`, който представя указател, който сам се грижи за динамично заделената памет на ресурса, който управлява (т.нар. *smart pointer*), и не позволява два различни уникални указателя да сочат към един и същи обект. Класът да поддържа следния интерфейс:

- **външна функция** `unique_ptr<T> make_unique(T const& data)`, която връща уникален указател към ресурса `data`;

- `unique_ptr(T* ptr)`, който "поема притежание" над обекта, сочен от `ptr`;

- `T& operator*()`, който връща референция към обекта, който притежава даден уникален указател;

- `T const& operator*() const` - подобно на горния метод;

- `T* operator->()`, който връща "raw" указателя, който се съдържа в уникалния указател;

- `T const* const operator->() const` - подобно на горния метод;

- `T* release()`, който "отдава" притежанието си над обекта, сочен от указателя;

- `void swap(unique_ptr& other)`, който размества съдържанията на два уникални указателя;

- `bool valid() const`, който връща дали даден указател е валиден;

- `operator bool() const`, аналогичен на горния метод.

## Задача 03

Да се напише клас `Set`, който представя множество, чиито елементи са цели числа. За класа да се напишат методи с подходящи сигнатури, изпълняващи следните функционалности:

- обединение на две множества;

- сечение на две множества;

- разлика на две множества;

- симетрична разлика на две множества;

- проверка дали дадено множество е празното такова;

- релацията $\subseteq$ за две множества;

- равенство на две множества, *позовавайки се на по-горните методи*;

- извеждане на елементите на множеството във форматиран вид на стандартния изход;

*Забележка 1*: За първите четири метода ще искаме да е възможно верижното им извикване, т.е. искаме да можем компактно да запишем нещо от вида $A_1 \cup A_2 \cup ... \cup A_n$. При наличие на няколко различни операции над множествата не се интересуваме от техния приоритет и приемаме, че операциите се извършват лявоасоциативно.  

*Забележка 2*: За методите, за които е възможно, предефинирайте подходящи оператори, които да изпълняват по-горните функционалности. Например, можем да използваме `operator+`, за да бележим обединението на две множества.

*Бонус*: Да се модифицира класът така, че елементите да бъдат от произволен тип.

## Задача 04

Използвайки класа за множество от [Задача 03](#задача-03), напишете клас `Relation`, представящ хомогенна бинарна релация. Приемаме, че елементите, които са в релация, са представени като наредени двойки. Да се напишат следните методи на класа:

- констуктор, който приема поредица от наредени двойки, представящи елементите, които са в релация;

- `void reflexiveClosure()`, която изгражда рефлексивното затваряне на релацията;

- `void symmetricClosure()`, която изгражда симетричното затваряне на релацията;

- `bool isEquivalenceRelation() const`, която проверява дали дадена релация е релация на еквивалентност.

*Бонус*: Да се модифицира класът така, че елементите на множеството да могат да бъдат от произволен тип.

## Задача 05

Да се напише клас `Matrix`, представящ матрица от реални числа от произволна размерност `MxN`, която *се знае по време на компилация*. За класа да се напишат методи с подходящи сигнатури, изпълняващи следните функционалности:

- събиране на две матрици;

- умножение на матрица със скалар, $\lambda M = M \lambda$;

- умножение на две матрици.