# Множествено наследяване - 22.05.2025г.

## Задача 00

Да се определи поведението на всеки от следните кодови фрагменти:

1.

```c++
struct A {};
struct B : A {
  virtual void foo() {}
};
struct C : A {
  virtual void foo() {}
};
struct D : B, C {
  void foo() {
    foo();
  }
  void bar() {
    // как ще извикаме foo съответно от B, C и D?
  }
};
```

2.

```c++
struct A {
  int i = 42; 
};
struct B : A {};
struct C : A {};
struct D : B, C {};

D d;
std::cout << d.i << '\n';
std::cout << ++d.B::i << '\n';
std::cout << --d.C::i; << '\n';

std::cout << ((B)d).i << '\n';
std::cout << ((C)d).i << '\n';
```

3. 

```c++
struct A {
  int i = 42;
};
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C {};

D d;
std::cout << d.i << '\n';
std::cout << ++d.B::i << '\n';
std::cout << --d.C::i << '\n';

std::cout << ((B)d).i << '\n';
std::cout << ((C)d).i << '\n';
```

4.

```c++
struct Base {
  int i = 42;
};
struct A : Base {};
struct B : virtual Base {};
struct C : virtual Base {};
struct D : A, B, C {};

D d;
std::cout << d.i << '\n';
std::cout << (d.A::i += 10) << '\n';
std::cout << d.B::i-- << '\n';
std::cout << d.C::i << '\n';
```

5.

```
struct A {
  A(int i) : i(i) {}
  int i;
};
struct B : virtual A {
  B() : A(1) {}
};
struct C : virtual A {
  C() : A(2) {}
};
struct D : B, C {
  D() {}
};

std::cout << ((B)D()).i << '\n';
std::cout << ((C)D()).i << '\n';
```

6.

```c++
 struct A {
  A(int i) : i(i) {}
  int i; 
};
struct B : A {
  B() : A(1) {}
};
struct C : A {
  C() : A(2) {}
};
struct D : B, C {
  D() : C(), B() {}
};

std::cout << ((B)D()).i << '\n';
std::cout << ((C)D()).i << '\n';
```

## Задача 01

*Забележка: Тази задача щеше да звучи по-добре на английски...*

Да се напише клас `Character`, който представлява герой във видео игра. Всеки герой има определено количество кръв и мана в зависимост от ролята си в играта. Освен това всеки герой има свое име и определена атака, силата и необходимата мана за която се задават при създаването на герой.

Да се напише клас `Tank`, чиито инстанции имат начални стойности за кръв и мана съответно `4000` и `800`. В началото атаките на тези герои не могат да надвишават атаките на който и да е друг вид герои. Силата на техните атаки расте обратно пропорционално на оставащата им кръв по следния начин:

```
<attack_dmg> = (100 + <percentage_lost_hp>) / 100 * <base_attack_dmg>
```

Освен това, ако даден tank е паднал под 40% живот, получава допълнителна устойчивост (?) и атаките от други герои нанасят с определен процент по-малко щети (??), равен на разликата между дадената критична точка (40%) и оставащите му проценти живот.

Да се напише клас `Assassin`, чиито инстанции имат начални стойност за кръв и мана съответно `1500` и `600`. За сметка на това техните атаки са сравнително по-силни от тези на tank-овете.

Да се напише клас `Bruiser`, който е смесица от предишните два класа. Този вид герои, подобно на асасините, имат първоначална стойност за мана `600` и кръв, равна на полусбора на кръвта на tank-овете и асасините. 

Да се напише клас `Healer`, чиито инстанции имат начални стойности за кръв и мана съответно `1000` и `1400`. Техните атаки не засягат вражеските герои, а повишават кръвта на герой от техния отбор. Освен това имат и допълнителна способност да засилват следващите си `n` атаки, като числото `n` става известно със създаването на героя. Тази способност има и съответен cooldown, равен на `2*n`, който започва да тече след използването на последната засилена атака.

Да се напише клас `Paladin`, комбинация от tank и healer, с начална стойност на кръвта `3000` и мана - `1100`. За разлика от healer-ите те не могат да засилват атаките си.

Да се реализира примерна програма, използваща по-горните класове. Да се създадат два отбора с еднакъв брой герои. За всяка атака, направена от някой герой, да се извежда подробно съобщение за това, кой герой атакува и кого бива атакуван и какви са оставащите кръв и мана на тези два героя. Ако даден герой активира някоя спефицична за него способност, да се изведе подробно съобщение, което описва състоянието на тази способност.
