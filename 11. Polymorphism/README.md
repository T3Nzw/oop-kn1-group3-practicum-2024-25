# Полиморфизъм - 08.05.2025г.

## Задача 00

За класа `Shape` от [миналия път](../10. Single Inheritance/README.md) да се напише допълнителна функция `print` и да се предефинира операторът за извеждане в изходен поток, като те да извеждат подходяща информация за съответната фигура. Да се определи кои от методите на класа трябва да бъдат чисто виртуални. Какъв е смисълът класът `Shape` да е абстрактен?

Да се създаде хетерогенен контейнер от фигури. За всяка от фигурите от контейнера да се изведе подходяща информация.

*Бонус*: Да се напише клас итератор, който обхожда даден хетерогенен контейнер (може сами да изберете какъв да бъде той) и за всеки елемент на контейнера прилага член функция на класа, която се подава при създаване на итератор към началото на контейнера.

## Задача 01

*Забележка*: Първоначално се опитайте да реализирате двата класа, без да използвате шаблони. Без ограничение на общността може да приемете, че указателите ще сочат към `int` стойности (или други типове, за които са реализирани подходящите оператори за правилното функциониране на долните два класа). 

Да се напишат класове за споделен указател и за слаб указател (видове умни указатели, т.е. указатели, които сами се грижат за заделената от тях памет). За тях са характерни следните неща:

- споделен указател - съдържа информация за това, колко "активни" споделени и слаби указателя сочат към един и същи ресурс в паметта. Всичките указатели, които сочат към един и същи ресурс, споделят тази памет (т.е. не се прави дълбоко копие на ресурса при създаване на нов споделен указател към него). Споделените указатели "притежават" ресурса, към който сочат. По този начин той бива освободен едва когато не останат никакви указатели, които да сочат към него (колко пъти написах "сочат към ..."?...). Класът да има следния интерфейс:

  - проверка дали указател е валиден;

  - връщане на обекта, сочещ се от указателя, както и на самия "raw" указател. За целта да се предефинират подходящи оператори;

  - размяна на два указателя;

  - "нулиране" на указателя;

  - два вида сравнение на споделени указатели:

    - ще казваме, че два указателя са еквивалентни, ако ресурсите, към които сочат, имат равни стойности;

    - ще казваме, че два указателя са равни, ако сочат към един и същи ресурс в паметта.

  - необходимите методи от голямата четворка (или от голямата шестица, ако се чувствате уверени в нея от семинарите ;) ).

- слаб указател - съдържа информация за това, колко "активни" споделени и слаби указателя сочат към един и същи ресурс в паметта. Всичките указатели, които сочат към един и същи ресурс, споделят тази памет. Слабите указатели, за разлика от споделените, НЕ притежават ресурса, към който сочат. Ако към даден обект не сочат никакви "активни" споделени указатели, то този ресурс става невалиден (expired), дори и да има слаби указатели, които да продължават да сочат към него. Класът да има следния интерфейс:

  - проверка дали указател е валиден;

  - проверка дали указател е expired. Считаме, че невалиден указател е различен от expired указател;

  - превръщане на non-expired слаб указател до споделен такъв;

  - двата вида сравнение дали два слаби указателя са съответно еквивалентни и равни;

  - размяна на два указателя;

  - оператори за достъпване на ресурса и на "raw" указателя в обекта;

  - необходимите методи от голямата четворка (или голямата шестица).

*Упътване*: Забележете, че към един и същи ресурс в паметта може да има едновременно няколко споделени и няколко слаби указателя. Трябва по някакъв начин да пазите и динамично да увеличавате (или намалявате) броя на "активните" указатели, които сочат към ресурса. 


