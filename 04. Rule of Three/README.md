# Голяма четворка (Rule of Three, RO3) - 10.03.2025

## Задача 00

Нека е даден следният клас:

```c++
class A {
public:
  A() { std::cout << "default ctor\n"; }
  A(int) { std::cout << "parametrized ctor\n"; }
  A(A const&) { std::cout << "copy ctor\n"; }
  A& operator=(A const&) { std::cout << "copy assignment operator\n"; return *this; }
  ~A() { std::cout << "dtor\n"; }
private:
  int x;
};
```

До какво поведение биха довели следните редове код:

```c++
  {
1.  A a1, a2(4);
2.  A a3(a1);
3.  A a4 = a2;
4.  a1 = a3 = a4;
5.  A const a5 = a3 = a2;
6.  a4 = 5;
7.  a2 = 'a';
8.  a5 = a1;
  }
```

```c++
  {
1.  A a1;
2.  A* p1;
3.  p1 = &a1;
4.  A* p2 = new A;
5.  A a2 = *p2;
  }
```

#### *Малък съвет*: Запазете си файловете за следните класове на лесно запомнящо се място на компютъра ви, тъй като ще се наложи да ги ползваме и доразвиваме и през следващите упражнения. :)

Реализациите на следните класове да бъдат съпроводени от примерна програма, която демонстрира коректност на работата на класа.

## Задача 01

Да се напише клас `String`, който позволява работа с низ, паметта за който е *динамично заделена*, и който има следните методи:

- подходящо реализирани методи от голямата четворка;

- параметризиран конструктор, който приема низ (C-style string, a не - обект на класа!);

- `bool empty() const`, който проверява дали даденият низ е празен;

- `void push_back(char c)`, който долепя символа `c` накрая на низа;

- `bool pop_back()`, който премахва последния символ от низа, ако това е възможно;

- `size_t size() const`, който връща размера на низа;

- `size_t capacity() const`, който връща капацитета на низа;

- `size_t find(char c) const`, който връща индекса на първото срещане на символа `c`;

- `size_t find(String const& substr) const`, който връща индекса на първото срещане на низа `substr`;

- `String slice(size_t left, size_t right)`, който връща подниза, започващ на индекс `left` и чийто последен символ се намира на индекс `right-1`;

- `void clear()`, който "изчиства" съдържанието в обекта;

- `void copy(String const& other)`, който копира `other` в текущия обект;

- `void reverse()`, който обръща низа;

- `void reserve(size_t capacity)`, който заделя `capacity` количество памет за дадения низ;

- `void erase(size_t index, size_t length=1)`, който изтрива `length` на брой символи, започвайки от индекса `index`;

- `void swap(String& other)`, който разменя двата низа;

- `char const* c_str() const`, който връща C-style низът, съдържащ се в обекта;

- `char* data()`, който прави същото като горния метод;

- `String& replace(char const* oldS, char const* newS)`, който заменя срещанията на `oldS` с `newS`;

- `String& replace(String const& oldS, String const& newS)`, който прави същото като горния метод.

## Задача 02

Да се напише шаблон на клас `Vector`, който има следните методи:

- подходящо реализирани методи от голямата четворка;

- следните параметризирани конструктори:

  - `Vector(size_t capacity, T const& initEl=T())`, който заделя `capacity` памет за вектора и инициализира всичките му клетки със стойността `initEl`;

  - `Vector(std::initializer_list<T> const& l)`, който инициализира елементите на вектора с тези от инициализиращия списък `l`.

- проверка дали векторът е празен;

- методи, които връщат размер и капацитет на вектора;

- добавяне на елемент накрая на вектора;

- премахване на последния елемент на вектора;

- вмъкване на елемент на даден индекс;

- премахване на елемент по индекс;

- метод за достъпване на елемент на даден индекс;

- изчистване на съдържанието на вектора;

- метод, който разменя съдържанията на два **вектора**.