# Голяма четворка (Rule of Three)

Голямата четворка се състои от:

- констуктор по подразбиране (не участва в т.нар. Rule of Three);

- констуктор за копиране;

- копиращ оператор за присвояване;

- деструктор.

По подразбиране тези четири метода се създават и се базират на т.нар. тривиално копиране **освен в следните случаи**:

- класът има константно поле;

- класът има поле, което е референция;

- класът е производен и базовият клас няма дефинирани горните методи (при наследяване).

Освен това ще пишем голяма четворка и за да избегнем споделяне на памет между обектите на даден клас.

---

### Тривиално копиране

```c++
class A {
private:
  int foo;
  double bar;
};

class B {
private:
  short int baz;
  A qux;
};
```

Клас наричаме тривиално копируем, ако няма потребителски дефинирани конструктор за копиране, копиращ оператор за присвояване и деструктор и всичките му полета също са тривиално копируеми. Класовете `A` и `B` са именно такива. Горната дефиниция не означава, че те нямат съответните методи - напротив, те се създават по подразбиране.

```c++
B b1;
B b2 = b1;  //извиква се констукторът за копиране

//можем да си мислим, че то се извършва както следва:
b1:
{
  short int baz;
  A qux
        {
          int foo;
          double bar;
        }
}

b2 = b1:
{
  short int baz = b1.baz;
  A qux
        {
          int foo = b1.foo;
          double bar = b1.bar;
        }
}
//тоест, буквално единият обект се копира
//в другия побитово в реда, в който са дефинирани
//полетата на класа
```

На този принцип (плюс някои особености, за които ще говорим по-надолу) се имплементират конструкторът за копиране и копиращият оператор за присвояване.

Конструкторът по подразбиране и деструкторът не правят нищо, т.е. имат празни тела:

```c++
B::B() {}
B::~B() {}
```

## Констуктор по подразбиране и параметризирани конструктори (Default constructor and parametrized constructors)

- базов пример

```c++
class Counter {
public:
  void inc() { m_count++; }
  void dec() { m_count--; }
  unsigned int getCount() const { return m_count; }
public:
  Counter() { m_count = 0; }
  Counter(unsigned int count) { m_count = count; }
private:
  unsigned int m_count;
};

assert(Counter().getCount()==0);
assert(Counter(2).getCount()==2);
Counter counter(10);
counter.inc();
assert(counter.getCount()==11);
```

- пример със споделяне на памет. Ще използваме този опростен пример за динамичен масив и в следващите секции:

```c++
class Array {
public:
  void push_back(int el) { /*...*/}
public:
  Array()
  : m_data(nullptr), m_size(0), m_capacity() {}

  Array(size_t capacity) : m_data(new int[capacity]), 
  m_size(0), m_capacity(capacity) {}

private:
  int* m_data;
  size_t m_size;
  size_t m_capacity;
};
```

Ако се опитаме да копираме един обект от тип `Array` в друг, на пръв поглед няма да имаме проблем - по подразбиране са се създали конструктор за копиране и копиращ оператор за присвояване. Обаче `m_data` е указател към масив, а при тривиалното копиране се копира само указателят - това означава, че полетата `m_data` на двата обекта ще сочат към един и същи масив и ще имаме споделяне на памет.

```c++
Array a1(10);
Array a2(a1);  //конструктор за копиране
//промените по единия масив засягат и другия!
a2.push_back(1);
a2.push_back(2);
/*
a2.m_data == [1,2]
a1.m_data == [1,2]
*/
```

За целта можем сами да укажем как искаме да се копират полетата на класа чрез потребителски дефиниран конструктор за копиране.

## Конструктор за копиране (Copy constructor)

В случая можем просто да заделим памет за нов масив и да копираме всичките елементи в него:

```c++
Array(Array const& other) : m_data(new int[other.m_size]),
m_size(other.m_size), m_capacity(other.m_size) {
  //първо се извършват операциите в инициализиращия
  //списък и чак след това се изпълнява тялото
  for (size_t i = 0; i < m_size; ++i) {
    m_data[i] = other.m_data[i];
  }
}
```

Причината да подаваме обекта като **референция** към **константа**, е, че:

- не можем да подадем нещо от тип `Array`, тъй като, за да се копира този обект при подаването, е необходимо да има дефиниран конструктор за копиране, т.е. ще изпаднем в безкраен цикъл;

- ако конструкторът приемаше референция, която не е към константа, нямаше да можем да подаваме константни обекти и rvalue-та.

## Копиращ оператор за присвояване (Copy assignment operator)

Много прилича на конструктора за копиране, с няколко разлики:

```c++
Array& operator=(Array const& other) {
  if (this != &other) {
    delete[] m_data;
    m_data = new int[other.m_size];
    m_size = m_capacity = other.m_size;
    for (size_t i = 0; i < m_size; ++i) {
      m_data[i] = other.m_data[i];
    }
  }
  return *this;
}
```

Ключовите разлики са, че:

- се използва за присвояване на друга стойност на **вече съществуващ** обект;

- операторът за присвояване *връща* резултат, който е референция - именно това позволява верижното му извикване, което сме виждали досега;

- правим проверка дали указателят към текущия обект `this` съвпада с адреса на другия обект `&other`, т.е. проверяваме дали двата обекта се намират на едно и също място в паметта - дали са *един и същи обект*. Ако не правехме тази проверка и двата обекта съвпадаха, то първо бихме освободили паметта, към която сочи `m_data` (`delete[] m_data`), и след това бихме се опитали да копираме елементите от вече деалокирана памет;

- функцията връща дереференцирания указател `this`, т.е. връща текущия обект.

## Деструктор (Destructor)

По подразбиране деструкторът не прави абсолютно нищо - това означава, че бихме имали изтичане на памет, тъй като никъде не освобождаваме динамично заделената памет.

```c++
~Array() { delete[] m_data; }
```

## Инициализиращ списък (Initializer list)

Можем да инициализираме полетата на даден клас, преди да бъде извикано тялото на някой конструктор - това става чрез т.нар. *инициализиращ списък*.

```c++
class Array {
public:
  Array(Array const& other)
  : m_data(new int[other.m_size]), m_size(other.m_size), m_capacity(other.m_capacity) {
    for (size_t i = 0; i < m_size; ++i)
      m_data[i] = other.m_data[i];
  }
private:
  int* m_data;
  size_t m_size, m_capacity;
};
```

Но какъв е смисълът от инициализиращия списък?

Инициализациите в него се извършват **преди** самата конструкция на обекта. Тоест,

- чрез него можем да инициализираме **константните** полета на класа:

  ```c++
  class OneOrMoreConstantDataMembers {
  public:
    OneOrMoreConstantDataMembers()
    : x(42), y(1.618) {}
  private:
    int const x;
    double const y;
  };
  ```

- чрез него можем да инициализираме полетата на класа, които са референции:

  ```c++
  class OneOrMoreReferenceDataMembers {
  public:
    OneOrMoreReferenceDataMembers(int& a)
    : ref1(a), ref2(3.14) {}
  private:
    int& ref1;
    double const& ref2;
  };
  ```

- чрез него се избягва допълнително създаване и присвояване на обекти. Нека приемем, че `X` е клас, който има сравнително тежки за изпълнение методи от голямата четворка (т.е. имат много операции):

  ```c++
  class Y {
  public:
    Y(X const& obj1, X const& obj2, X const& obj3) {
      this->obj1 = obj1;
      this->obj2 = obj2;
      this->obj3 = obj3;
    }
  private:
    X obj1, obj2, obj3;
  };
  ```

  В този случай, дори и да не сме написали инициализиращия списък експлицитно, **полетата се инициализират**, в случая със стойностите по подразбиране на `X` (т.е. вика се конструкторът по подразбиране). След това в тялото на параметризирания конструктор на `Y` се извиква 3 пъти операторът за присвояване на обектите от тип `X`. Можем да си спестим това и да извикваме само копиращия конструктор, използвайки инициализиращия списък на `Y`:

  ```c++
  class Y {
  public:
    Y(X const& obj1, X const& obj2, X const& obj3) 
    : obj1(obj1), obj2(obj2), obj3(obj3) {}
  private:
    X obj1, obj2, obj3;
  };
  ```

- ако липсва конструктор по подразбиране за някое от полетата на класа. Тоест, ако в по-горния пример `X` нямаше конструктор по подразбиране, нямаше да можем да напишем първия фрагмент от код, тъй като не бихме имали начин да конструираме тези обекти. В такъв случай инициализациите им се пишат в инициализиращия списък.

## Инициализация по подразбиране (Default member initializer)

Освен чрез инициализиращ списък или в тялото на някой конструктор можем да инициализираме полетата на класа направо с тяхната декларация:

```c++
class A {
public:
  A() : y(15) {
    z = 20;
  }
private:
  int x = 0, y = 5, z = 10;
};
```

Важно е да отбележим, че ако някое поле на класа е инициализирано по подразбиране, но след това е инициализирано в инициализиращия списък или тялото на някой конструктор, то стойността по подразбиране **се игнорира** (`y==15` и `z==20`). В противен случай стойността е тази от инициализацията по подразбиране (`x==0`).

## Ключовите думи default и delete

Можем експлицитно да укажем, че някои от методите от голямата четворка се държат като тези по подразбиране:

```c++
class A {
public:
  A()=default;
  A(A const&)=default;
  A& operator=(A const&)=default;
  ~A()=default;
};
```

Можем и да изтрием някои от тези методи:

```c++
class B {
  B()=delete;
  B(B const&)=delete;
  B& operator=(B const&)=delete;
  ~B()=delete;
};
```

## Допълнителни неща:

### Принципът RAII (Resource Acquisition Is Initialization)

### Избягване на копиране (Copy elision)

### Method reference qualifiers